/*
  Motor Control for Vine Bed Transfer
  Sreela Kodali kodali@stanford.edu

  modified by Godson Osele (5/31/24) to add CommandOverTime command to BLE motorService

  This creates a BLE peripheral with a service that contains multiple
  characteristics to control different groups of the brushless motors.
*/

#include <ArduinoBLE.h>
#include <Servo.h>


#define N_ACT 8   // Number of actuators, 8 motors
#define N_CMDS 9 // number of commands

// These are the range of PWM values the SPARK Max Controller understands
// See PWM Input Specs here for more details:
// https://docs.revrobotics.com/sparkmax/specifications
// The PWM signal that goes to the Spark Max is generated by a function called
// writeMicroseconds(x).
// motor.writeMicroseconds(1025) = reverse max speed
// motor.writeMicroseconds(1500) = neutral, no movement
// motor.writeMicroseconds(2000) = forwawrd max speed

typedef enum {
  MOTOR_MIN = 1025,
  MOTOR_NEUTRAL = 1500,
  MOTOR_MAX = 2000
} MOTOR_LIMITS;


// IF YOU WANT TO SEND THE SAME COMMAND TO GROUPS OF MOTORS
// I created a little structure "cmd" (short for "command") where you give it a name,
// and identify which motors you want to run with a binary array so you can run different
// groups of motors at the same time! For example, if I want to control motors 1-4 at the
// same time, I'd add the following to my allCommands[] array:
//         initializeCmd("myCommand", {1, 1, 1, 1, 0, 0, 0, 0, 0})
// Then, when I open the app and connect with the Arduino, "myCommand" will appear as an
// option where I can write/send one value that'll go to motors 1-4.

struct cmd {
  char* strname;
  int* motors;
  BLEIntCharacteristic ble;
};

cmd initializeCmd(char* s, int* m) {
  BLEIntCharacteristic bleCharacteristic("2A59", BLEWrite);  // 2A59, analog output
  BLEDescriptor des("2901", s);                              // adding user description (2901) for the characteristic
  bleCharacteristic.addDescriptor(des);
  bleCharacteristic.writeValue(0);
  cmd c{ s, m, bleCharacteristic };
  return c;
}

BLEService motorService("01D");  // Bluetooth® Low Energy, motorized device


// IMPORTANT!!!
// IF YOU WANT TO ADJUST THE RANGE, RESOLUTION, SPEEDS FOR THE MAPPING OF BLE-TO-MOTOR CMDS,
// ETC. BEYOND THE DEFAULT TEN PRESET VALUES, READ THIS!

// The default works simply and as follows: We have a small integer array of length 10 called
// uSCommandValues (abbreviation for // microsecondCommandValues) that has 10 distinct motor
// commands within the SparkMax's valid range between 1000 and 2000 (https://docs.revrobotics.com/sparkmax/specifications),
// as shown on line 90.
// The BLE commands are the index for this array. So for example, if someone sends
// a "1" command via their phone to the motors, the motors would receive
// writeMicroseconds(usCommandValues[1])=MOTOR_MIN.
// If you'd like different values, feel free to change the content and/or length of USCommandVValues
const int uSCommandValues[10] = { MOTOR_NEUTRAL, MOTOR_MIN, 1185, 1285, 1385, MOTOR_NEUTRAL, 1650, 1750, 1850, MOTOR_MAX };


const int neutralCMD_min = 1450;
const int neutralCMD_max = 1550;
// which motors will be on for each command

// tcw1, tcw2, tcw3, tcw4, base1, base2, base3, base4, pressure regulator
int motors_CMD1[N_ACT] = { 0, 0, 0, 0, 1, 1, 1, 1 };
int motors_CMD2[N_ACT] = { 1, 1, 1, 1, 0, 0, 0, 0 };
int motors_CMD3[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };
int motors_CMD4[N_ACT] = { 0, 0, 0, 0, 0, 0, 0, 0 };
int motors_CMD5[N_ACT] = { 0, 0, 0, 0, 0, 0, 0, 0 };
int motors_CMD6[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };  // Example: Command for single motor with duration
int motors_CMD7[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };  // Command for all motors with two speeds and duration
// New command for sending different speeds to different halves and swapping
int motors_CMD8[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };  // Placeholder for the new command




cmd allCommands[N_CMDS] = {
  initializeCmd("allBase", motors_CMD1),
  initializeCmd("allTCWTurn", motors_CMD2),
  initializeCmd("allBaseTCWTurn", motors_CMD3),
  initializeCmd("individualMotor", motors_CMD4),
  initializeCmd("pressureReg", motors_CMD5),
  initializeCmd("PreLoadValues", motors_CMD4),
  initializeCmd("CommandOverTime", motors_CMD8),      // New command for motor with duration
  initializeCmd("motorsWithTwoSpeeds", motors_CMD8),  // New command for all motors with two speeds and duration
  initializeCmd("halfAndHalfSwap", motors_CMD8)      // New command for sending different speeds to different halves and swapping
};
// initializeCmd("PreLoadValues_Acc", motors_CMD4)};

Servo motorArr[N_ACT];

// these pins correspond  to different motor's input
const int pins_CommandOUTArr[N_ACT] = { 2, 3, 4, 5, 6, 7, 8, 9 };

void setup() {
  //
  //  Serial.begin(9600);
  //  while (!Serial);

  // begin initialization
  if (!BLE.begin()) {
    while (1)
      ;  // Serial.println("starting Bluetooth® Low Energy module failed!");
  }

  // set advertised local name and service UUID:
  BLE.setLocalName("Nano 33 BLE");
  BLE.setAdvertisedService(motorService);

  // set LED pin to output mode
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(LEDR, OUTPUT);
  pinMode(LEDG, OUTPUT);
  pinMode(LEDB, OUTPUT);

  digitalWrite(LEDR, HIGH);  // off
  digitalWrite(LEDG, HIGH);  // off
  digitalWrite(LEDB, HIGH);  // off

  for (int i = 0; i < N_ACT; ++i) {
    motorArr[i].attach(pins_CommandOUTArr[i]);  // connect each motor to PWM output
    // if (i == (N_ACT - 1)) {
    //   motorArr[i].writeMicroseconds(PRESSURE_NEUTRAL);
    // } else {
    motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
    //}
  }

  for (int i = 0; i < N_CMDS; ++i) {
    motorService.addCharacteristic(((allCommands[i]).ble));  // add the characteristic to the service
  }

  BLE.addService(motorService);  // add service
  BLE.advertise();               // start advertising

  //    Serial.println("Initialized.");
}

// length is how many bytes you want to send
int extractByte(int length, int idx, unsigned long commandValue) {

  if (idx > (length - 1)) {
    return -1; // -1 is error
  } else {
    int valueArr[length];
    if (length == 3) {
      valueArr[0] = (commandValue & 0x000F) >> 0;
      valueArr[1] = (commandValue & 0xF000) >> 12;
      valueArr[2] = (commandValue & 0x0F00) >> 8;
    } else if (length == 8) {
      valueArr[0] = (commandValue & 0x000000F0) >> 4;
      valueArr[1] = (commandValue & 0x0000000F) >> 0;
      valueArr[2] = (commandValue & 0x0000F000) >> 12;
      valueArr[3] = (commandValue & 0x00000F00) >> 8;
      valueArr[4] = (commandValue & 0x00F00000) >> 20;
      valueArr[5] = (commandValue & 0x000F0000) >> 16;
      valueArr[6] = (commandValue & 0xF0000000) >> 28;
      valueArr[7] = (commandValue & 0x0F000000) >> 24;    
    }
    return valueArr[idx];
  }
}

void handleHalfAndHalfSwapCommand(unsigned long commandValue) {
  //expected 3 values delivered as hexadecimal

  int speed1Idx = extractByte(3, 0, commandValue);//From most significant bit
  int speed2Idx = extractByte(3, 1, commandValue); // From 'mid'bit
  int duration = extractByte(3, 2, commandValue);// OR 

  // Serial.println(speed1Idx);
  // Serial.println(speed2Idx);
  // Serial.println(duration);

  int speed1 = uSCommandValues[speed1Idx];
  int speed2 = uSCommandValues[speed2Idx];

  // Set first half of motors to speed1 and second half to speed2
  for (int i = 0; i < N_ACT / 2; ++i) {
    motorArr[i].writeMicroseconds(speed1);
  }
  for (int i = N_ACT / 2; i < N_ACT; ++i) {
    motorArr[i].writeMicroseconds(speed2);
  }
  delay(duration * 1000);  // Convert duration to seconds

  // Set all motors back to neutral
  for (int i = 0; i < N_ACT; ++i) {
    motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
  }

  delay(3000);  // 3 second delay between commands

  // Swap the speeds: Set first half to speed2 and second half to speed1
  for (int i = 0; i < N_ACT / 2; ++i) {
    motorArr[i].writeMicroseconds(speed2);
  }
  for (int i = N_ACT / 2; i < N_ACT; ++i) {
    motorArr[i].writeMicroseconds(speed1);
  }
  delay(duration * 1000);  // Convert duration to seconds

  // Set all motors back to neutral
  for (int i = 0; i < N_ACT; ++i) {
    motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
  }
}


void loop() {

  // listen for Bluetooth® Low Energy peripherals to connect:
  BLEDevice central = BLE.central();

  // if a central is connected to peripheral:
  if (central) {

    // while the central is still connected to peripheral:
    while (central.connected()) {
      // if the remote device wrote to the characteristic,
      // use the value to control the LED:

      for (int i = 0; i < N_CMDS; ++i) {
        if (((allCommands[i]).ble).written()) {

          digitalWrite(LED_BUILTIN, HIGH);  // turn on LED value for commmand being sent

          char* n = (allCommands[i]).strname;

          if (n == "PreLoadValues") {
            unsigned long x = ((allCommands[i]).ble).value();
            int commands[8];

            for (int k = 0; k < N_ACT; ++k) {
              commands[k] = 0;
            }

            for (int k = 0; k < N_ACT; ++k) {
              commands[k] = extractByte(8, k, x);
            }

            // commands[0] = extractByte(8, 0, x);
            // commands[1] = (x & 0x0000000F) >> 0;
            // commands[2] = (x & 0x0000F000) >> 12;
            // commands[3] = (x & 0x00000F00) >> 8;
            // commands[4] = (x & 0x00F00000) >> 20;
            // commands[5] = (x & 0x000F0000) >> 16;
            // commands[6] = (x & 0xF0000000) >> 28;
            // commands[7] = (x & 0x0F000000) >> 24;

            int sendCommand = 0;
            for (int k = 0; k < N_ACT; ++k) {
              int idx = commands[k];
              //Serial.println(idx);
              if (idx >= 10 or idx < 1) {
                sendCommand = sendCommand + 1;
              }
            }
            if (sendCommand == 0) {
              for (int k = 0; k < N_ACT; ++k) {
                int idx = commands[k];
                // Serial.println(commands[k]);
                motorArr[k].writeMicroseconds(uSCommandValues[idx]);
              }
              // write commands
            } else {
              for (int k = 0; k < N_ACT; ++k) {
                motorArr[k].writeMicroseconds(MOTOR_NEUTRAL);
                // Serial.println("STOP");
              }
            }

          } else if (n == "CommandOverTime") {
            unsigned long x = allCommands[i].ble.value();
            
            int motorIndex = extractByte(3, 0, x);  // Extract motor index from high byte
            int speedIdx = extractByte(3, 1, x);    // Extract speed index from mid byte
            int duration = extractByte(3, 2, x);            // Extract duration from low byte

            if (motorIndex < N_ACT && speedIdx >= 0 && speedIdx < 10) {
              int speed = uSCommandValues[speedIdx];
              motorArr[motorIndex].writeMicroseconds(speed);
              delay(duration * 1000);  // Convert duration to milliseconds
              motorArr[motorIndex].writeMicroseconds(MOTOR_NEUTRAL);
            }
          } else if (strcmp(n, "motorsWithTwoSpeeds") == 0) {
            unsigned long x = allCommands[i].ble.value();
            int speedIdx1 = extractByte(3, 0, x);  // Extract first speed index from high byte
            int speedIdx2 = extractByte(3, 1, x);;   // Extract second speed index from mid byte
            int duration = extractByte(3, 2, x);;           // Extract duration from low byte

            if (speedIdx1 >= 0 && speedIdx1 < 10 && speedIdx2 >= 0 && speedIdx2 < 10) {
              int speed1 = uSCommandValues[speedIdx1];
              int speed2 = uSCommandValues[speedIdx2];

              for (int j = 0; j < N_ACT; ++j) {
                motorArr[j].writeMicroseconds(speed1);
              }
              delay(duration * 1000);  // Convert duration to milliseconds

              for (int j = 0; j < N_ACT; ++j) {
                motorArr[j].writeMicroseconds(MOTOR_NEUTRAL);
              }
              delay(duration * 1000);  // Neutral duration

              for (int j = 0; j < N_ACT; ++j) {
                motorArr[j].writeMicroseconds(speed2);
              }
              delay(duration * 1000);  // Second speed duration

              for (int j = 0; j < N_ACT; ++j) {
                motorArr[j].writeMicroseconds(MOTOR_NEUTRAL);
              }
            }
          } else if (strcmp(n, "halfAndHalfSwap") == 0) {
            unsigned long commandValue = allCommands[i].ble.value();
            handleHalfAndHalfSwapCommand(commandValue);
          }
          // following logic holds for allBase, allTCWTurn, allBaseTCWTurn, individualMotors
          else {

            unsigned long x = ((allCommands[i]).ble).value();
            unsigned long z = (x & 0b11110000) >> 4;
            x = (x & 0b00001111);
            int y = MOTOR_NEUTRAL;  // Fix: if it's command for pressure, different default value
                                    //            Serial.println(x, HEX);

            // if value > 16, change motorArr to make sure motor of MSB turns on
            if (z) {
              for (int j = 0; j < N_ACT; ++j) {
                if (z - 1 == j) {
                  (allCommands[i]).motors[j] = 1;
                } else {
                  (allCommands[i]).motors[j] = 0;
                }
              }
            }
            // otherwise read LSB as motor command
            if (x >= 0 && x < 10) {
              y = uSCommandValues[(int)x];  // Fix: if it's command for pressure, different value
              //Serial.println(y);
            } else {
              //Serial.println("Invalid input");
              digitalWrite(LED_BUILTIN, HIGH);  //blink to show invalid input
              delay(250);
              digitalWrite(LED_BUILTIN, LOW);
              delay(250);
              digitalWrite(LED_BUILTIN, HIGH);
              delay(250);
              digitalWrite(LED_BUILTIN, LOW);
              delay(250);
              digitalWrite(LED_BUILTIN, HIGH);
              delay(250);
              digitalWrite(LED_BUILTIN, LOW);
            }

            if (y > neutralCMD_min && y < neutralCMD_max) {
              digitalWrite(LEDR, HIGH);
              digitalWrite(LEDG, HIGH);
              digitalWrite(LEDB, LOW);
            } else if (y < neutralCMD_min) {
              digitalWrite(LEDR, LOW);
              digitalWrite(LEDG, HIGH);
              digitalWrite(LEDB, HIGH);
            } else if (y > neutralCMD_max) {
              digitalWrite(LEDR, HIGH);
              digitalWrite(LEDG, LOW);
              digitalWrite(LEDB, HIGH);
            } else {
              digitalWrite(LEDR, HIGH);
              digitalWrite(LEDG, HIGH);
              digitalWrite(LEDB, HIGH);
            }

            for (int j = 0; j < N_ACT; ++j) {
              if ((allCommands[i]).motors[j]) {
                motorArr[j].writeMicroseconds(y);
              } else {
                motorArr[j].writeMicroseconds(MOTOR_NEUTRAL);
              }
            }
          }
          delay(500);
        }
        digitalWrite(LED_BUILTIN, LOW);  // turn off LED
      }
    }

    // when the central disconnects, print it out:
    // Serial.print(F("Disconnected from central: "));
    // Serial.println(central.address());
  }
}
